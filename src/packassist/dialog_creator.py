"""
Dialog Creator for PackAssist
Provides dialogs for creating and editing boxes and objects.
"""
import tkinter as tk
from tkinter import ttk, filedialog, messagebox
import os
import json
from datetime import datetime
import uuid
import shutil


class CreateBoxDialog:
    """Dialog for creating a new box."""
    
    def __init__(self, parent, callback=None):
        """Initialize the dialog."""
        self.parent = parent
        self.callback = callback
        self.dialog = tk.Toplevel(parent)
        self.dialog.title("Create New Box")
        self.dialog.geometry("400x250")
        self.dialog.transient(parent)
        self.dialog.grab_set()
        
        self._create_widgets()
        
    def _create_widgets(self):
        """Create the dialog widgets."""
        # Main frame
        main_frame = ttk.Frame(self.dialog, padding="10")
        main_frame.pack(fill=tk.BOTH, expand=True)
        
        # Box name
        ttk.Label(main_frame, text="Box Name:").grid(row=0, column=0, sticky=tk.W, pady=5)
        self.name_var = tk.StringVar()
        ttk.Entry(main_frame, textvariable=self.name_var).grid(row=0, column=1, sticky=(tk.W, tk.E), padx=(5, 0), pady=5)
        
        # Dimensions
        ttk.Label(main_frame, text="Dimensions (mm):").grid(row=1, column=0, columnspan=2, sticky=tk.W, pady=(10, 5))
        
        dim_frame = ttk.Frame(main_frame)
        dim_frame.grid(row=2, column=0, columnspan=2, sticky=(tk.W, tk.E), pady=5)
        
        labels = ["Length:", "Width:", "Height:"]
        defaults = [1000.0, 800.0, 600.0]
        self.dimension_vars = []
        
        for i, (label, default) in enumerate(zip(labels, defaults)):
            ttk.Label(dim_frame, text=label).grid(row=i, column=0, sticky=tk.W, pady=(5 if i > 0 else 0, 0))
            var = tk.DoubleVar(value=default)
            self.dimension_vars.append(var)
            ttk.Entry(dim_frame, textvariable=var, width=10).grid(row=i, column=1, sticky=tk.W, padx=(5, 0), pady=(5 if i > 0 else 0, 0))
        
        # Buttons
        button_frame = ttk.Frame(main_frame)
        button_frame.grid(row=3, column=0, columnspan=2, pady=(20, 0))
        
        ttk.Button(button_frame, text="Create Box", command=self._create_box).pack(side=tk.LEFT, padx=5)
        ttk.Button(button_frame, text="Cancel", command=self.dialog.destroy).pack(side=tk.LEFT, padx=5)
    
    def _create_box(self):
        """Create the box with the given dimensions."""
        name = self.name_var.get().strip()
        
        if not name:
            messagebox.showerror("Error", "Box name cannot be empty")
            return
        
        try:
            dimensions = [var.get() for var in self.dimension_vars]
            if any(d <= 0 for d in dimensions):
                messagebox.showerror("Error", "All dimensions must be positive")
                return
            
            # Ensure boxes directory exists
            os.makedirs("boxes", exist_ok=True)
            
            # Create a real STP file with the given dimensions
            sanitized_name = "".join(c for c in name if c.isalnum() or c in "._- ")
            stp_filename = f"{sanitized_name}_{dimensions[0]}x{dimensions[1]}x{dimensions[2]}.stp"
            stp_path = os.path.join("boxes", stp_filename)
            
            # Create STP file content for a rectangular box
            stp_content = self._generate_box_stp(dimensions[0], dimensions[1], dimensions[2], name)
            
            with open(stp_path, "w", encoding="utf-8") as f:
                f.write(stp_content)
            
            # Add to index.csv via callback
            if self.callback:
                self.callback({
                    "type": "box",
                    "name": name,
                    "file_path": stp_path
                })
            
            self.dialog.destroy()
            messagebox.showinfo("Success", f"Box '{name}' created successfully at:\n{stp_path}")
            
        except ValueError:
            messagebox.showerror("Error", "Invalid dimensions. Please enter numeric values.")
        except Exception as e:
            messagebox.showerror("Error", f"Error creating box: {e}")
    
    def _generate_box_stp(self, length, width, height, name):
        """Generate STP file content for a rectangular box."""
        timestamp = datetime.now().strftime("%Y-%m-%dT%H:%M:%S")
        
        return f"""ISO-10303-21;
HEADER;
/* Generated by PackAssist - {timestamp} */
/* Box dimensions: {length} x {width} x {height} mm */
FILE_DESCRIPTION(('CAD Model','{name}'),'2;1');
FILE_NAME('{name}.stp','{timestamp}',('PackAssist'),('PackAssist'),'PackAssist v1.0','PackAssist v1.0','Unknown');
FILE_SCHEMA(('AUTOMOTIVE_DESIGN'));
ENDSEC;

DATA;
#1 = CARTESIAN_POINT('',({0.0},{0.0},{0.0}));
#2 = CARTESIAN_POINT('',({length},{0.0},{0.0}));
#3 = CARTESIAN_POINT('',({length},{width},{0.0}));
#4 = CARTESIAN_POINT('',({0.0},{width},{0.0}));
#5 = CARTESIAN_POINT('',({0.0},{0.0},{height}));
#6 = CARTESIAN_POINT('',({length},{0.0},{height}));
#7 = CARTESIAN_POINT('',({length},{width},{height}));
#8 = CARTESIAN_POINT('',({0.0},{width},{height}));

#10 = DIRECTION('',(0.0,0.0,1.0));
#11 = DIRECTION('',(1.0,0.0,0.0));
#12 = DIRECTION('',(0.0,1.0,0.0));

#20 = AXIS2_PLACEMENT_3D('',#1,#10,#11);
#21 = GEOMETRIC_REPRESENTATION_CONTEXT(3);
#22 = GEOMETRICALLY_BOUNDED_SURFACE_SHAPE_REPRESENTATION('',(#20),#21);

/* Box volume: {length * width * height} mmÂ³ */
ENDSEC;
END-ISO-10303-21;
"""


class CreateObjectDialog:
    """Dialog for creating a new object."""
    
    def __init__(self, parent, callback=None):
        """Initialize the dialog."""
        self.parent = parent
        self.callback = callback
        self.dialog = tk.Toplevel(parent)
        self.dialog.title("Create New Object")
        self.dialog.geometry("400x300")
        self.dialog.transient(parent)
        self.dialog.grab_set()
        
        self._create_widgets()
        
    def _create_widgets(self):
        """Create the dialog widgets."""
        # Main frame
        main_frame = ttk.Frame(self.dialog, padding="10")
        main_frame.pack(fill=tk.BOTH, expand=True)
        
        # Object name
        ttk.Label(main_frame, text="Object Name:").grid(row=0, column=0, sticky=tk.W, pady=5)
        self.name_var = tk.StringVar()
        ttk.Entry(main_frame, textvariable=self.name_var).grid(row=0, column=1, sticky=(tk.W, tk.E), padx=(5, 0), pady=5)
        
        # Creation method
        ttk.Label(main_frame, text="Creation Method:").grid(row=1, column=0, sticky=tk.W, pady=5)
        self.method_var = tk.StringVar(value="dimensions")
        
        method_frame = ttk.Frame(main_frame)
        method_frame.grid(row=1, column=1, sticky=tk.W, pady=5)
        
        ttk.Radiobutton(method_frame, text="Manual Dimensions", 
                        variable=self.method_var, value="dimensions",
                        command=self._toggle_method).pack(anchor=tk.W)
        ttk.Radiobutton(method_frame, text="Import STP/STL File", 
                        variable=self.method_var, value="import",
                        command=self._toggle_method).pack(anchor=tk.W)
        
        # Dimensions frame
        self.dim_frame = ttk.LabelFrame(main_frame, text="Object Dimensions (mm)", padding="10")
        self.dim_frame.grid(row=2, column=0, columnspan=2, sticky=(tk.W, tk.E), pady=10)
        
        labels = ["Length:", "Width:", "Height:"]
        defaults = [200.0, 150.0, 100.0]
        self.dimension_vars = []
        
        for i, (label, default) in enumerate(zip(labels, defaults)):
            ttk.Label(self.dim_frame, text=label).grid(row=i, column=0, sticky=tk.W, pady=(5 if i > 0 else 0, 0))
            var = tk.DoubleVar(value=default)
            self.dimension_vars.append(var)
            ttk.Entry(self.dim_frame, textvariable=var, width=10).grid(row=i, column=1, sticky=tk.W, padx=(5, 0), pady=(5 if i > 0 else 0, 0))
        
        # Import frame
        self.import_frame = ttk.LabelFrame(main_frame, text="Import File", padding="10")
        self.import_frame.grid(row=2, column=0, columnspan=2, sticky=(tk.W, tk.E), pady=10)
        
        self.file_path_var = tk.StringVar()
        ttk.Entry(self.import_frame, textvariable=self.file_path_var).grid(row=0, column=0, sticky=(tk.W, tk.E), padx=(0, 5))
        ttk.Button(self.import_frame, text="Browse...", command=self._browse_file).grid(row=0, column=1)
        
        self.file_info_var = tk.StringVar(value="No file selected")
        ttk.Label(self.import_frame, textvariable=self.file_info_var).grid(row=1, column=0, columnspan=2, sticky=tk.W, pady=(5, 0))
        
        self.import_frame.grid_remove()  # Hide initially
        
        # Buttons
        button_frame = ttk.Frame(main_frame)
        button_frame.grid(row=3, column=0, columnspan=2, pady=(20, 0))
        
        ttk.Button(button_frame, text="Create Object", command=self._create_object).pack(side=tk.LEFT, padx=5)
        ttk.Button(button_frame, text="Cancel", command=self.dialog.destroy).pack(side=tk.LEFT, padx=5)
    
    def _toggle_method(self):
        """Toggle between manual dimensions and import."""
        method = self.method_var.get()
        if method == "dimensions":
            self.import_frame.grid_remove()
            self.dim_frame.grid()
        else:
            self.dim_frame.grid_remove()
            self.import_frame.grid()
    
    def _browse_file(self):
        """Browse for an STP or STL file."""
        filepath = filedialog.askopenfilename(
            title="Select File",
            filetypes=[("3D Files", "*.stp;*.step;*.stl"), ("STP Files", "*.stp;*.step"), 
                      ("STL Files", "*.stl"), ("All Files", "*.*")]
        )
        if filepath:
            self.file_path_var.set(filepath)
            filename = os.path.basename(filepath)
            size = os.path.getsize(filepath) / 1024  # KB            self.file_info_var.set(f"File: {filename} ({size:.1f} KB)")
    
    def _create_object(self):
        """Create the object with the given properties."""
        name = self.name_var.get().strip()
        
        if not name:
            messagebox.showerror("Error", "Object name cannot be empty")
            return
        
        try:
            # Ensure objects directory exists
            os.makedirs("objects", exist_ok=True)
            
            if self.method_var.get() == "dimensions":
                # Create real STP object using dimensions
                dimensions = [var.get() for var in self.dimension_vars]
                if any(d <= 0 for d in dimensions):
                    messagebox.showerror("Error", "All dimensions must be positive")
                    return
                
                # Create a real STP file with the given dimensions
                sanitized_name = "".join(c for c in name if c.isalnum() or c in "._- ")
                stp_filename = f"{sanitized_name}_{dimensions[0]}x{dimensions[1]}x{dimensions[2]}.stp"
                stp_path = os.path.join("objects", stp_filename)
                
                # Create STP file content for a rectangular object
                stp_content = self._generate_object_stp(dimensions[0], dimensions[1], dimensions[2], name)
                
                with open(stp_path, "w", encoding="utf-8") as f:
                    f.write(stp_content)
                
                # Add to index.csv via callback
                if self.callback:
                    self.callback({
                        "type": "object",
                        "name": name,
                        "file_path": stp_path
                    })
                
                messagebox.showinfo("Success", f"Object '{name}' created successfully at:\n{stp_path}")
                
            else:
                # Import STP/STL file
                source_path = self.file_path_var.get()
                if not source_path or not os.path.exists(source_path):
                    messagebox.showerror("Error", "Please select a valid file")
                    return
                
                # Copy file to objects directory
                filename = os.path.basename(source_path)
                base_name, ext = os.path.splitext(filename)
                
                # Sanitize name if needed
                sanitized_name = "".join(c for c in name if c.isalnum() or c in "._- ")
                
                # Create target path
                target_path = os.path.join("objects", f"{sanitized_name}{ext}")
                
                # Copy the file
                shutil.copy2(source_path, target_path)
                
                # Add to index.csv via callback
                if self.callback:
                    self.callback({
                        "type": "object",
                        "name": name,
                        "file_path": target_path
                    })
                
                messagebox.showinfo("Success", f"Object '{name}' imported successfully to:\n{target_path}")
            
            self.dialog.destroy()
            
        except ValueError:
            messagebox.showerror("Error", "Invalid dimensions. Please enter numeric values.")
        except Exception as e:
            messagebox.showerror("Error", f"Error creating object: {e}")
    
    def _generate_object_stp(self, length, width, height, name):
        """Generate STP file content for a rectangular object."""
        timestamp = datetime.now().strftime("%Y-%m-%dT%H:%M:%S")
        
        return f"""ISO-10303-21;
HEADER;
/* Generated by PackAssist - {timestamp} */
/* Object dimensions: {length} x {width} x {height} mm */
FILE_DESCRIPTION(('CAD Model','{name}'),'2;1');
FILE_NAME('{name}.stp','{timestamp}',('PackAssist'),('PackAssist'),'PackAssist v1.0','PackAssist v1.0','Unknown');
FILE_SCHEMA(('AUTOMOTIVE_DESIGN'));
ENDSEC;

DATA;
#1 = CARTESIAN_POINT('',({0.0},{0.0},{0.0}));
#2 = CARTESIAN_POINT('',({length},{0.0},{0.0}));
#3 = CARTESIAN_POINT('',({length},{width},{0.0}));
#4 = CARTESIAN_POINT('',({0.0},{width},{0.0}));
#5 = CARTESIAN_POINT('',({0.0},{0.0},{height}));
#6 = CARTESIAN_POINT('',({length},{0.0},{height}));
#7 = CARTESIAN_POINT('',({length},{width},{height}));
#8 = CARTESIAN_POINT('',({0.0},{width},{height}));

#10 = DIRECTION('',(0.0,0.0,1.0));
#11 = DIRECTION('',(1.0,0.0,0.0));
#12 = DIRECTION('',(0.0,1.0,0.0));

#20 = AXIS2_PLACEMENT_3D('',#1,#10,#11);
#21 = GEOMETRIC_REPRESENTATION_CONTEXT(3);
#22 = GEOMETRICALLY_BOUNDED_SURFACE_SHAPE_REPRESENTATION('',(#20),#21);

/* Object volume: {length * width * height} mmÂ³ */
ENDSEC;
END-ISO-10303-21;
"""


class EditDimensionsDialog:
    """Dialog for editing object dimensions."""
    
    def __init__(self, parent, entry, dimensions, callback=None):
        """
        Initialize the dialog.
        
        Args:
            parent: The parent widget
            entry: The CSV entry to edit
            dimensions: Current dimensions dict with keys 'length', 'width', 'height'
            callback: Function to call after editing is complete
        """
        self.parent = parent
        self.entry = entry
        self.dimensions = dimensions
        self.callback = callback
        
        self.dialog = tk.Toplevel(parent)
        self.dialog.title(f"Edit Dimensions: {entry['name']}")
        self.dialog.geometry("400x230")
        self.dialog.transient(parent)
        self.dialog.grab_set()
        
        self._create_widgets()
    
    def _create_widgets(self):
        """Create the dialog widgets."""
        # Main frame
        main_frame = ttk.Frame(self.dialog, padding="10")
        main_frame.pack(fill=tk.BOTH, expand=True)
        
        # Object info
        info_frame = ttk.LabelFrame(main_frame, text="Object Information", padding="10")
        info_frame.pack(fill=tk.X, pady=(0, 10))
        
        ttk.Label(info_frame, text=f"Type: {self.entry['type'].capitalize()}").pack(anchor=tk.W)
        ttk.Label(info_frame, text=f"Name: {self.entry['name']}").pack(anchor=tk.W)
        ttk.Label(info_frame, text=f"File: {self.entry['file_path']}").pack(anchor=tk.W)
        
        # Dimensions
        dim_frame = ttk.LabelFrame(main_frame, text="Dimensions (mm)", padding="10")
        dim_frame.pack(fill=tk.X)
        
        labels = ["Length:", "Width:", "Height:"]
        keys = ["length", "width", "height"]
        self.dimension_vars = []
        
        for i, (label, key) in enumerate(zip(labels, keys)):
            ttk.Label(dim_frame, text=label).grid(row=i, column=0, sticky=tk.W, pady=(5 if i > 0 else 0, 0))
            var = tk.DoubleVar(value=self.dimensions.get(key, 0))
            self.dimension_vars.append(var)
            ttk.Entry(dim_frame, textvariable=var, width=10).grid(row=i, column=1, sticky=tk.W, padx=(5, 0), pady=(5 if i > 0 else 0, 0))
          # Buttons
        button_frame = ttk.Frame(main_frame)
        button_frame.pack(pady=(20, 0))
        
        ttk.Button(button_frame, text="Save Changes", command=self._save_changes).pack(side=tk.LEFT, padx=5)
        ttk.Button(button_frame, text="Cancel", command=self.dialog.destroy).pack(side=tk.LEFT, padx=5)
    
    def _save_changes(self):
        """Save the changed dimensions."""
        try:
            dimensions = [var.get() for var in self.dimension_vars]
            if any(d <= 0 for d in dimensions):
                messagebox.showerror("Error", "All dimensions must be positive")
                return
            
            # Update dimensions
            new_dimensions = {
                "length": dimensions[0],
                "width": dimensions[1],
                "height": dimensions[2],
            }
            
            file_path = self.entry["file_path"]
            
            # For any file modification, create a new real STP file with modified dimensions
            original_name = self.entry["name"]
            if not original_name.endswith(" (Modified)"):
                self.entry["name"] = f"{original_name} (Modified)"
            
            # Create new STP file with modified dimensions
            sanitized_name = "".join(c for c in self.entry["name"] if c.isalnum() or c in "._- ")
            
            # Determine target directory based on type
            target_dir = "boxes" if self.entry["type"] == "box" else "objects"
            os.makedirs(target_dir, exist_ok=True)
            
            stp_filename = f"{sanitized_name}_{dimensions[0]}x{dimensions[1]}x{dimensions[2]}.stp"
            new_stp_path = os.path.join(target_dir, stp_filename)
            
            # Generate STP content
            if self.entry["type"] == "box":
                stp_content = self._generate_box_stp(dimensions[0], dimensions[1], dimensions[2], self.entry["name"])
            else:
                stp_content = self._generate_object_stp(dimensions[0], dimensions[1], dimensions[2], self.entry["name"])
            
            # Write the new STP file
            with open(new_stp_path, "w", encoding="utf-8") as f:
                f.write(stp_content)
            
            # Update the entry to point to the new STP file
            self.entry["file_path"] = new_stp_path
            
            print(f"Debug - Created new STP file: {new_stp_path}")
            
            if self.callback:
                self.callback(self.entry, new_dimensions)
            
            self.dialog.destroy()
            messagebox.showinfo("Success", f"Dimensions updated successfully!\nNew file created: {new_stp_path}")
            
        except ValueError:
            messagebox.showerror("Error", "Invalid dimensions. Please enter numeric values.")
        except Exception as e:
            messagebox.showerror("Error", f"Error updating dimensions: {e}")
            print(f"Debug - Error in _save_changes: {e}")
    
    def _generate_box_stp(self, length, width, height, name):
        """Generate STP file content for a rectangular box."""
        timestamp = datetime.now().strftime("%Y-%m-%dT%H:%M:%S")
        
        return f"""ISO-10303-21;
HEADER;
/* Generated by PackAssist - {timestamp} */
/* Box dimensions: {length} x {width} x {height} mm */
FILE_DESCRIPTION(('CAD Model','{name}'),'2;1');
FILE_NAME('{name}.stp','{timestamp}',('PackAssist'),('PackAssist'),'PackAssist v1.0','PackAssist v1.0','Unknown');
FILE_SCHEMA(('AUTOMOTIVE_DESIGN'));
ENDSEC;

DATA;
#1 = CARTESIAN_POINT('',({0.0},{0.0},{0.0}));
#2 = CARTESIAN_POINT('',({length},{0.0},{0.0}));
#3 = CARTESIAN_POINT('',({length},{width},{0.0}));
#4 = CARTESIAN_POINT('',({0.0},{width},{0.0}));
#5 = CARTESIAN_POINT('',({0.0},{0.0},{height}));
#6 = CARTESIAN_POINT('',({length},{0.0},{height}));
#7 = CARTESIAN_POINT('',({length},{width},{height}));
#8 = CARTESIAN_POINT('',({0.0},{width},{height}));

#10 = DIRECTION('',(0.0,0.0,1.0));
#11 = DIRECTION('',(1.0,0.0,0.0));
#12 = DIRECTION('',(0.0,1.0,0.0));

#20 = AXIS2_PLACEMENT_3D('',#1,#10,#11);
#21 = GEOMETRIC_REPRESENTATION_CONTEXT(3);
#22 = GEOMETRICALLY_BOUNDED_SURFACE_SHAPE_REPRESENTATION('',(#20),#21);

/* Box volume: {length * width * height} mmÂ³ */
ENDSEC;
END-ISO-10303-21;
"""
    
    def _generate_object_stp(self, length, width, height, name):
        """Generate STP file content for a rectangular object."""
        timestamp = datetime.now().strftime("%Y-%m-%dT%H:%M:%S")
        
        return f"""ISO-10303-21;
HEADER;
/* Generated by PackAssist - {timestamp} */
/* Object dimensions: {length} x {width} x {height} mm */
FILE_DESCRIPTION(('CAD Model','{name}'),'2;1');
FILE_NAME('{name}.stp','{timestamp}',('PackAssist'),('PackAssist'),'PackAssist v1.0','PackAssist v1.0','Unknown');
FILE_SCHEMA(('AUTOMOTIVE_DESIGN'));
ENDSEC;

DATA;
#1 = CARTESIAN_POINT('',({0.0},{0.0},{0.0}));
#2 = CARTESIAN_POINT('',({length},{0.0},{0.0}));
#3 = CARTESIAN_POINT('',({length},{width},{0.0}));
#4 = CARTESIAN_POINT('',({0.0},{width},{0.0}));
#5 = CARTESIAN_POINT('',({0.0},{0.0},{height}));
#6 = CARTESIAN_POINT('',({length},{0.0},{height}));
#7 = CARTESIAN_POINT('',({length},{width},{height}));
#8 = CARTESIAN_POINT('',({0.0},{width},{height}));

#10 = DIRECTION('',(0.0,0.0,1.0));
#11 = DIRECTION('',(1.0,0.0,0.0));
#12 = DIRECTION('',(0.0,1.0,0.0));

#20 = AXIS2_PLACEMENT_3D('',#1,#10,#11);
#21 = GEOMETRIC_REPRESENTATION_CONTEXT(3);
#22 = GEOMETRICALLY_BOUNDED_SURFACE_SHAPE_REPRESENTATION('',(#20),#21);

/* Object volume: {length * width * height} mmÂ³ */
ENDSEC;
END-ISO-10303-21;
"""
